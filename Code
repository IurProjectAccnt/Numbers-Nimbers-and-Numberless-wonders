#include <glut.h>
#include <vector>
#include <iostream>
#include <string>
#include <time.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.0, 1.0, 0.0);
	/*glBegin(GL_LINES);
	glVertex2f(50, 50);
	glVertex2f(150, 200);*/
	//glBegin(GL_QUADS);
	srand(time(NULL));
	for (int j = 0; j <= 8; ++j)
	{
		glBegin(GL_LINES);
		glVertex2f(60, 60 + j * 60);
		glVertex2f(540, 60 + j * 60);
		glEnd();
		glFlush();
	}
	for (int j = 0; j <= 8; ++j)
	{
		glBegin(GL_LINES);
		glVertex2f(60 + j * 60, 60);
		glVertex2f(60 + j * 60, 540);
		glEnd();
		glFlush();
	}//рисовка таблицы
	//vector<int,int> n(60);
	bool cell[10][10];
	string name1, name2;
	int x1, y1, i;
	int j = 0;
	int itmp = 0;
	cout << "Игроки, скажите мне свои имена!" << endl;
	cin >> name1 >> name2;
	for (i = 0; i < 10; ++i)
	{
		for (j = 0; j < 10; ++j)
		{
			cell[i][j] = true;
		}
	}
	for (i = 1; i < 9; ++i)
	{
		for (j = 1; j < 9; ++j)
		{
			cell[i][j] = false;
		}
	}//подготовка поля	
	for (i = 0; i < 33; ++i)
	{
		j = 0;
		if (i % 2 == 1)
		{
			cout << "Сейчас ходит " << name1 << "." << endl;
		}
		else
		{
			cout << "Сейчас ходит " << name2 << "." << endl;
		}
		if(i%2==1)
		{
			cin >> x1 >> y1;
		}
		itmp = i;
		bool true_place = false;
		if (i % 2 == 0)
		{//
			for (; (cell[x1][y1] == true || cell[x1][y1 - 1] == true);)
			{
				y1 = 8;
				x1 = 2;
				for (; cell[x1][y1] == true || cell[x1][y1 - 1] == true,y1>1;)
				{
					y1 -= 1;
					if (cell[x1][y1]==false && cell[x1][y1 - 1] == false)
					{
						true_place = true;
						break;
					}
				}
				if (true_place)
				{
					break;
				}
				y1 = 8;
				x1 = 7;
				for (; cell[x1][y1] == true || cell[x1][y1 - 1] == true, y1>1;)
				{
					y1 -= 1;
					if (cell[x1][y1] == false && cell[x1][y1 - 1] == false)
					{
						true_place = true;
						break;
					}
				}
				if (true_place)
				{
					break;
				}
				for (; cell[x1][y1] == true || cell[x1][y1-1] == true;)
				{
					x1 = rand() % 8 + 1;
					y1 = rand() % 7 + 2;
				}
			}//
			if (cell[x1][y1] == false && cell[x1][y1 - 1] == false)
			{
				cell[x1][y1] = true;
				cell[x1][y1 - 1] = true;
				glColor3f(1.0, 0.0, 0.0);
				glBegin(GL_TRIANGLES);

				glVertex2f(60 * x1 + 30, y1 * 60 + 60);
				glVertex2f(x1 * 60, y1 * 60);
				glVertex2f(x1 * 60 + 60, y1 * 60);

				glEnd();
				glFlush();

				glBegin(GL_TRIANGLES);

				glVertex2f(x1 * 60, y1 * 60);
				glVertex2f(x1 * 60 + 60, y1 * 60);
				glVertex2f(60 * x1 + 30, y1 * 60 - 60);


				glEnd();
				glFlush();
				cout << x1 << " " << y1<<endl;
			}
		}
		else if (i % 2 == 1)
		{
			if (cell[x1][y1] == false && cell[x1 + 1][y1] == false)
			{
				cell[x1][y1] = true;
				cell[x1 + 1][y1] = true;
				glColor3f(0.0, 0.0, 1.0);
				glBegin(GL_TRIANGLES);

				glVertex2f((x1 + 1) * 60, y1 * 60 + 60);
				glVertex2f(x1 * 60, y1 * 60 + 30);
				glVertex2f((x1 + 1) * 60, y1 * 60);

				glEnd();
				glFlush();

				glBegin(GL_TRIANGLES);

				glBegin(GL_TRIANGLES);

				glVertex2f((x1 + 1) * 60, y1 * 60 + 60);
				glVertex2f(x1 * 60 + 120, y1 * 60 + 30);
				glVertex2f((x1 + 1) * 60, y1 * 60);


				glEnd();
				glFlush();
			}
			else
			{
				cout << "Какая-то из данных ячеек уже занята, попробуйте ещё раз." << endl;
				i -= 1;
				continue;
			}
		}
		for (int k = 1; k < 9; ++k)
		{
			for (int k1 = 1; k1 < 9; ++k1)
			{
				if (itmp % 2 ==1)
				{
					if (cell[k][k1] == true && (cell[k - 1][k1] == true || cell[k + 1][k1] == true))
					{
						++j;
					}
				}
				else
				{
					if (cell[k][k1] == true && (cell[k][k1-1] == true || cell[k][k1+1] == true))
					{
						++j;
					}
				}
			}
		}
		if (j == 64)
		{
			break;
		}
	}

	if (itmp % 2 == 1)
	{
		cout << "Побеждает " << name2 << "!"<<endl;
	}
	else
	{
		cout << "Побеждает " << name1 << "!"<<endl;
	}
}
int main(int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(640, 640);
	glutCreateWindow("Domineering");
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 640, 0, 640);
	glutDisplayFunc(display);
	setlocale(LC_ALL, "Russian");
	glutMainLoop();
}
